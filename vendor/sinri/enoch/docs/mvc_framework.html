<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web Framework</title>
    <link rel="stylesheet" href="./static/common.css">
</head>
<body>
<div class="outer_container">
    <h1 class="inner_container bottom_line">Web Framework of Enoch</h1>
    <div class="inner_container">
        <h2>Target</h2>
        <div class="inner_container">
            Why developers prefer framework than write service with pure PHP?
            Name it, they are lazy, we are lazy. We hate repeating the same tasks.
            So frameworks came out and make the web serving design in a fixed pattern, lessen the coding work.
        </div>
        <div class="inner_container">
            To serve web, there are three points, parsing request, passing request to right handler, finally output.
            We would later discuss around the three points. Now, let us recall the common sense of web.
            We should understand the fundamental knowledge.
            Client request sent to server contains URL and data, sometimes header as well.
            URL contains path and query string, joined with a question mark.
            Data could be anything as header content-type suggested or server determined.
            Headers are also a customizable field.
            As for output, headers and body are needed after handling.
            Output would be almostly in HTML format for page, and JSON format for data transferring.
        </div>
        <div class="inner_container">
            The framework do one thing generally only, that is, to pass request to right handler for output.
            For this target, several models would be introduced.
        </div>
        <div class="inner_container">
            The most simple design, is to fix the request URL to same script such as index.php,
            and read controller class name from act field, read method name from method field.
            With the act and method name, we can clearly know which class should be the handler.
            This method is useful for any server with standard HTTP support.
            Let us take an URL as example:
            <br><code>http://example.com/index.php?act=Action&method=Method</code><br>
            The above URL would pass to <code>Action::Method</code> to handle.
        </div>
        <div class="inner_container">
            This would make two field names reserved, which is not so good.
            So another design comes with query field free, but uses the first two extending path components,
            and take the others since the third as method parameters.
            Let us take an URL as example:
            <br><code>http://example.com/index.php/Action/Method/P1/P2</code><br>
            The above URL would pass to <code>Action::Method</code> to handle, with the parameters P1 and P2.
        </div>
        <div class="inner_container">
            Want one step deeper? You may also set up the routes for any URL.
            Now support mapping on the pair of Regex URL and callable object, i.e. class method or function.
            It is somewhat experimental now.
        </div>
    </div>
    <div class="inner_container bottom_line">
        <a href="./index.html">Contents</a>
    </div>
    <div class="footer_container">
        Copyright 2017 Sinri Edogawa, Licensed under MIT.
    </div>
</div>
</body>
</html>